---
title: "Introduction: Floyd Cycle Detection"
date: 2020-07-21T15:05:34+08:00
author: "Eklipsorz"
description : "一個利用兩個Pointer來解決List上的循環問題"
tags : [
    "Algorithm",
    "Cycle Detection",
]
categories : [
    "Algorithm",
]

markup: "mmark"

draft: true
---



當你想解決任何一個需要檢測在多個相互連接的元素是否著環狀結構之場景，比如說  
1. 道路模型。  
2. 由多個有限狀態所組成的數學模型。  
3. 有限輸入下在同一個函式$f(x)$所形成的結果，比如集合為$\\{1,2\\}$，且$f(1)=2$以及$f(2)=1$，在這裏1和2就透過函式關係形成一個環狀結構。  

你會怎麼檢測它？放棄它，反正以後碰不上？  
當然我會建議不放棄它，畢竟你不能夠確定在未來路上不會遇上類似的問題，那麼正式進入正題，如果冷靜思考的話，其實不論哪一個場景，都可以將這
些場景轉化成由多個節點所組成的結構：


![](/img/floydCycleDetect/ListAexample.png)

或者

![](/img/floydCycleDetect/ListBexample.png)


當我們轉換成如此的結構時，我們可以更容易以肉眼看出哪些模型存在著循環，在這裏我們可以知道List A是存在著循環，而List B由於尾巴部分並未跟
前幾個節點相接，所以不構成循環。在這裡你或許會選擇以肉眼來辨識，但現實是當面對大量或者複雜的模型時，肉眼看會顯得效率太差，所以最好由電
腦進行這樣的重複辨識工作。    

可換作是電腦，它要如何辨識呢？畢竟他本身就不存在像人眼那樣的辨識模型，在這裏提供一個方法來幫助電腦辨識：Floyd's Cycle Detection Algorithm，
傳說是由Robert W. Floyd所發明的演算法，所以以它的名字來命名，普遍上會以演算法的特色來稱呼：龜兔賽跑算法。顧名思義，這個算法會假設一隻烏龜和
一隻兔子在這個許多節點構成的List結構進行賽跑，烏龜每次只能走一個節點，而兔子只能走二個節點，他們只要跑下去肯定能到循環裡，最終如果他們能在循
環中碰面或者在同一點會合的話，就表示這個結構上存在著循環。(如下圖所示)

{{< CenterImage
src="/img/floydCycleDetect/CycleExample.png"
alt="擁有循環的List結構" >}}

然而，如果兔子走到結構中的終點卻沒跟烏龜會合的話，那就表示著結構不存著循環。(如下圖)


{{< CenterImage
src="/img/floydCycleDetect/NoCycleExample.png"
alt="沒擁有循環的List結構" >}}

乍看之下這方法很簡單，但問題是這方法真能判別循環問題嗎？如果你對此也感到懷疑，歡迎到Proof章節來進行討論，但如果沒有的話，我可以告訴你
這方法確實能判別循環問題，而非是運氣，另外也建議讀者您參考Pseudo Code以及Performance這兩個章節來看其代碼以及成本。

## Proof:How it works?
首先我們先來考慮擁有循環的結構(如下圖)，在循環之前可能會有$N$個點或者沒存在任何節點，而這$N$的值會影響著烏龜和兔子在循環中的初始位置，再來
為了很好瞭解影響，設定了數字來表示循環中的第幾個節點，以$0$到$\lambda-1$來命名，而$\lambda$則是定義成循環中的長度-節點數，在這裡$\lambda=10$。

{{< CenterImage
src="/img/floydCycleDetect/NandCycle.png"
alt="沒擁有循環的List結構" >}}

首先我們先考慮著$N=0$時，兔子和烏龜會在循環的起點會合，並從那裡開始進行他們的賽跑。

{{< CenterImage
src="/img/floydCycleDetect/N0andCycle.png"
alt="沒擁有循環的List結構" >}}


根據兔子走兩步和烏龜走一步的前提，當兔子走完一圈時，烏龜才走半圈，而兔子在走完一圈時，這時烏龜才走完一圈，此時他們倆就在一開始的點會合。    

在這裡，我們會發現幾個有趣的觀察結果：  
1. 兔子得走完一圈才有辦法跟烏龜會合(p.s 他們倆不動也能會合XD，但這不是在該方法的討論範圍內)  
2. 兔子$H$的步數會是烏龜$T$的步數之一倍，換言之，$H=2T$。  
3. 延伸第二個結果，若沒有循環的存在，他們倆就可能沒辦法會合，但若是給予循環的存在，等同強制添加$mod\ \lambda$運算至$H$和$T$上才能判斷他們
是否會合（如下式），而如果都是一樣的話，便是代表在循環中會合；但如果都不是一樣，便是還未會合。


{{< CenterText
src="$H≡T$ ($mod\ λ$)"
>}}

{{< CenterText
src="$2T≡T$ ($mod\ λ$)"
>}}


統整這三個觀察結果，我們會發現只要$T=\lambda$ 代入上式，兔子和烏龜會在第$0$個節點會合。接下來我們思考另一種情況，如果$N=1$時，這種代入結果會不會有
所不同？

{{< CenterImage
src="/img/floydCycleDetect/N1andCycle.png"
alt="N = 1時的情況" >}}

從上圖可以觀察出當烏龜進入循環時的位置不是在與兔子在同一個節點，而是相差一個節點，這對於$N=0$所得出的觀察結果而言，兔子還是得走完一圈才有
辦法和烏龜在同一點，而且也不影響著兔子和烏龜原本要走的步數，由於當烏龜進入循環時的兔子所在位置不同而改變了第三種觀察結果。


首先兔子在循環中的位置會變成：

{{< CenterText
src="$H'=H+1$"
>}}


那麼這個新位置會不會影響和烏龜在同一點會合呢？只要我們按照圖上位置來模擬他們移動，最後會發現他們的確會在同一點會合，只是位置變成第$\lambda-1$個
位置或者最後一個位置-第九個位置。  

那麼第三個觀察結果會變成如下所示：
{{< CenterText
src="$H+1≡T$ ($mod\ λ$)"
>}}

{{< CenterText
src="$2T+1≡T$ ($mod\ λ$)"
>}}


接著我們再來思考一下$N=2$時，會有什麼樣的變化
{{< CenterImage
src="/img/floydCycleDetect/N2andCycle.png"
alt="N = 2時的情況" >}}

同樣的，由於只是單純增加循環外面的節點，不會影響著第一、二個觀察結果，而第三個結果中的兔子預期位置：

{{< CenterText
src="$H'=H+2$"
>}}

接著我們只要按照圖上位置來模擬他們移動就會發現他們的確也是會在同一點上會合，但這次是第$\lambda-2$個節點或者第8個節點上會合。如果考慮成$N=3$時，會發現會
在第$\lambda-3$個節點或者第$7$個節點上會合，而$N=4$時，會發現在第$\lambda-4$個節點或者第$6$個節點上會合。


那麼最後我們來試著考慮著$N=M$的情況，而M的範圍為$[1,∞)$，而定義成這範圍是由於我們只限定於不存在循環以外的
點以及存在$M$個循環以外的點，在此只討論後者，前者已在$N=0$討論過。

{{< CenterImage
src="/img/floydCycleDetect/NMandCycle.png"
alt="N = M時的情況" >}}

在這$N=M$的情況下，會使得兔子預期位置變成：  
{{< CenterText
src="$H'=H+M$"
>}}

在這裡我們還不確定這種情況是否同樣地使烏龜和兔子會在同一點會合，所以我們先假設他們肯定能在某一點會合來找出矛盾或者驗證其正確性，換言之，先定義出這式子：

{{< CenterText
src="$H+M≡T$ ($mod\ λ$)"
>}}

或者

{{< CenterText
src="$2T+M≡T$ ($mod\ λ$)"
>}}



根據前面所述的第ㄧ、二觀察結果，兔子必須得至少繞ㄧ圈才有機會與烏龜會合，但這樣單純繞幾圈也只是與烏龜保持$M-(0.5\lambda+M)$
個節點的距離，所以兔子和烏龜必須得多走個幾步才有機會會合，所以式子會變成如下：

{{< CenterText
src="$T=N_1\lambda+N_2$ (烏龜繞了$N_1$圈又$N_2$步)"
>}}


{{< CenterText
src="$2(N_1\lambda+N_2)+M≡N_1\lambda+N_2$ ($mod\ \lambda$)"
>}}

根據$mod λ$，我們可以化簡成：

{{< CenterText
src="$2N_2+M≡N_2$ ($mod\ \lambda$)"
>}}

根據先前$N=2-4$情況得到的觀察結果，會發現都會在第$\lambda-N$個節點會合，那麼同樣地將其結果套用在上式時，

{{< CenterText
src="$N_2=\lambda-M$"
>}}

會發現式子會變成如下:

{{< CenterText
src="$2(\lambda-M)+M≡(\lambda-M)$ ($mod\ \lambda$)"
>}}

再稍微用$mod\ \lambda$來化簡，則會是：
{{< CenterText
src="$-M≡-M$ ($mod\ \lambda$)"
>}}

而這相當於在第$\lambda-M$個節點或者第$\lambda-N$個節點會合

{{< CenterText
src="$\lambda-M≡\lambda-M$ ($mod\ \lambda$)"
>}}

從這樣推論驗證了$N$在$[1,∞)$範圍內的節點數所構成循環時可以使兔子和烏龜在第$\lambda-N$個節點會合。
